<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<style>
body {
  margin: 0;
  padding: 20px;
  font-family: system-ui, -apple-system, sans-serif;
}
.frobo-component {
  padding: 20px;
  margin: 10px;
  border: 1px solid #ddd;
  border-radius: 8px;
}

.frobo-component p {
  margin: 10px 0;
  font-size: 16px;
}

.frobo-component h1 {
  margin: 10px 0;
  font-size: 24px;
  font-weight: bold;
}

.frobo-component button {
  padding: 10px 20px;
  margin: 5px;
  background-color: #007bff;
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.frobo-component button:hover {
  background-color: #0056b3;
}

.frobo-component input {
  padding: 8px 12px;
  margin: 5px;
  border: 1px solid #ccc;
  border-radius: 4px;
  font-size: 14px;
}
</style>
</head>
<body>
<div id="Greeting" class="frobo-component">
  
  
  <h1>Greeting Switcher</h1>
  <p id="text-greeting-name" data-template="{greeting}, {name}!" data-vars="greeting,name">{greeting}, {name}!</p>
  <button onclick="sayHello()">Say Hello</button>
  <button onclick="sayHi()">Say Hi</button>
  <button onclick="sayHey()">Say Hey</button>
  <button onclick="changeName()">Change Name</button>
</div>




<script>
const Frobo = {
  state: {},
  dependencies: {},
  domBindings: [],
  updateQueue: new Set(),
  updateScheduled: false,
  
  watchers: {},
  
  createState(initialState) {
    const self = this;
    this.state = new Proxy(initialState, {
      set: (target, property, value) => {
        const oldValue = target[property];
        target[property] = value;
        self.scheduleUpdate(property);
        // Trigger watchers
        if (self.watchers[property]) {
          self.watchers[property].forEach(callback => callback(value, oldValue));
        }
        return true;
      }
    });
    return this.state;
  },
  
  addWatcher(stateKey, callback) {
    if (!this.watchers[stateKey]) {
      this.watchers[stateKey] = [];
    }
    this.watchers[stateKey].push(callback);
  },
  
  watch(stateKey, element) {
    if (!this.dependencies[stateKey]) {
      this.dependencies[stateKey] = [];
    }
    this.dependencies[stateKey].push(element);
  },
  
  scheduleUpdate(stateKey) {
    const self = this;
    this.updateQueue.add(stateKey);
    if (!this.updateScheduled) {
      this.updateScheduled = true;
      requestAnimationFrame(() => {
        self.flushUpdates();
      });
    }
  },
  
  flushUpdates() {
    const self = this;
    this.updateQueue.forEach(key => {
      self.updateDOM(key);
    });
    this.updateQueue.clear();
    this.updateScheduled = false;
  },
  
  updateDOM(stateKey) {
    const self = this;
    const elements = this.dependencies[stateKey];
    if (elements) {
      elements.forEach(element => {
        const template = element.getAttribute('data-template');
        if (template) {
          // Replace all variables in the template with their current state values
          let result = template;
          const vars = element.getAttribute('data-vars');
          if (vars) {
            vars.split(',').forEach(varName => {
              const regex = new RegExp('\{' + varName + '\}', 'g');
              result = result.replace(regex, String(self.state[varName]));
            });
          } else {
            // Fallback for single variable (old format)
            result = result.replace(new RegExp('\{' + stateKey + '\}', 'g'), String(self.state[stateKey]));
          }
          element.textContent = result;
        }
      });
    }
    this.domBindings
      .filter(binding => binding.stateKey === stateKey)
      .forEach(binding => {
        if (self.state[stateKey] !== undefined) {
          if (binding.property === 'textContent') {
            binding.element.textContent = String(self.state[stateKey]);
          } else if (binding.property === 'value') {
            binding.element.value = String(self.state[stateKey]);
          } else {
            binding.element.setAttribute(binding.property, String(self.state[stateKey]));
          }
        }
      });
    
    // Re-evaluate conditionals
    if (this.conditionals) {
      this.conditionals.forEach(evaluate => evaluate());
    }
    
    // Re-render loops
    if (this.renderLoops) {
      this.renderLoops();
    }
  },
  
  bind(elementId, stateKey, property = 'textContent') {
    const element = document.getElementById(elementId);
    if (element) {
      this.domBindings.push({ element, property, stateKey });
      this.updateDOM(stateKey);
    }
  },
  
  on(elementId, eventType, handler) {
    const element = document.getElementById(elementId);
    if (element) {
      element.addEventListener(eventType, handler);
    }
  },
  
  onClick(elementId, handler) {
    this.on(elementId, 'click', handler);
  },
  
  onChange(elementId, handler) {
    const element = document.getElementById(elementId);
    if (element && (element instanceof HTMLInputElement || element instanceof HTMLTextAreaElement)) {
      const updateHandler = (event) => {
        handler(event.target.value);
      };
      element.addEventListener('change', updateHandler);
      element.addEventListener('input', updateHandler);
    }
  }
};

// Initialize state
const state = Frobo.createState({ greeting: "Hello", name: "World" });
let greeting = state.greeting;
let name = state.name;

// Register reactive elements
window.addEventListener('DOMContentLoaded', () => {
  // Setup dynamic classes
  document.querySelectorAll('[data-dynamic-class]').forEach(el => {
    const classMap = JSON.parse(el.getAttribute('data-dynamic-class'));
    const updateClasses = () => {
      Object.entries(classMap).forEach(([className, condition]) => {
        if (state[condition]) {
          el.classList.add(className);
        } else {
          el.classList.remove(className);
        }
      });
    };
    updateClasses();
    Object.keys(classMap).forEach(className => {
      const condition = classMap[className];
      Frobo.addWatcher(condition, updateClasses);
    });
  });
  
  // Setup text element watchers
  document.querySelectorAll('[data-vars]').forEach(el => {
    const vars = el.getAttribute('data-vars').split(',');
    vars.forEach(varName => {
      Frobo.watch(varName, el);
    });
    // Initial update
    if (vars.length > 0) Frobo.updateDOM(vars[0]);
  });

  // Setup conditional rendering
  Frobo.setupConditionals = function() {
    document.querySelectorAll('[data-condition]').forEach(el => {
      const condition = el.getAttribute('data-condition');
      const condId = el.id.replace('-if', '');
      const ifBlock = document.getElementById(condId + '-if');
      const elseBlock = document.getElementById(condId + '-else');
      
      const evaluate = () => {
        try {
          const result = eval(condition);
          if (ifBlock) ifBlock.style.display = result ? 'block' : 'none';
          if (elseBlock) elseBlock.style.display = result ? 'none' : 'block';
        } catch(e) { console.error('Condition error:', e); }
      };
      
      evaluate();
      Frobo.conditionals = Frobo.conditionals || [];
      Frobo.conditionals.push(evaluate);
    });
  };
  
  Frobo.setupConditionals();
  
  // Setup input and textarea binding
  document.querySelectorAll('input[data-bind], textarea[data-bind]').forEach(input => {
    const stateKey = input.getAttribute('data-bind');
    const onChange = input.getAttribute('data-onchange');
    
    // Set initial value
    if (state[stateKey] !== undefined) {
      input.value = state[stateKey];
    }
    
    // Listen for changes
    input.addEventListener('input', (e) => {
      state[stateKey] = e.target.value;
      if (onChange && typeof window[onChange] === 'function') {
        window[onChange](e.target.value);
      }
    });
    
    // Update input when state changes
    const originalUpdate = Frobo.updateDOM;
    Frobo.updateDOM = function(key) {
      originalUpdate.call(this, key);
      if (key === stateKey && input.value !== String(state[stateKey])) {
        input.value = state[stateKey];
      }
    };
  });
  
  // Setup loop rendering
  Frobo.renderLoops = function() {
    document.querySelectorAll('[data-loop]').forEach(container => {
      const arrayName = container.getAttribute('data-loop');
      const itemName = container.getAttribute('data-item');
      const templateId = container.id + '-template';
      const template = document.getElementById(templateId);
      
      if (!template || !state[arrayName]) return;
      
      container.innerHTML = '';
      const array = state[arrayName];
      
      if (Array.isArray(array)) {
        array.forEach((item, index) => {
          const clone = template.content.cloneNode(true);
          const div = document.createElement('div');
          div.appendChild(clone);
          let html = div.innerHTML;
          html = html.replace(/\{\{LOOP_ITEM\}\}/g, item);
          container.innerHTML += html;
        });
      }
    });
  };
  
  Frobo.renderLoops();
});

function sayHello() {
  state.greeting = "Hello" ;

}

function sayHi() {
  state.greeting = "Hi" ;

}

function sayHey() {
  state.greeting = "Hey" ;

}

function changeName() {
  state.name = "Friend" ;

}

console.log("Frobo app loaded!");
</script>
</body>
</html>